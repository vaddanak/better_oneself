<!DOCTYPE html>
<HTML lang="en-US">
<HEAD>
    <link rel="stylesheet" href="code_page.css">
    <title>Code Page Template</title>
    <style>
        /* body {
            background-color: black;
            color: white;
        } */
    </style>
</HEAD>
<BODY >
<pre id="code">
<code>
    /******************************************************************************
    *  File: bunchofgraphs.h
    *  Author:  Vaddanak Seng
    *  Purpose: Header file contains class BunchOfGraphs definition.  It holds
    *     a collection of graph instances and provides Dijkstra algorithm to 
    *     find a path through a graph.      
    ******************************************************************************/
    
    #ifndef BUNCHOFGRAPHS_H_
    #  define BUNCHOFGRAPHS_H_
    
    #include "graph.h"
    
    #include <string>
    #include <vector>
    #include <queue>
    
    /**
    * Purpose:  It holds a collection of graph instances and provides Dijkstra
    *     algorithm to find a path through a graph.      
    * How-to-use:
    *     1)  BunchOfGraphs(const std::string&) creates instance using graph data
    *         in "filename" to create instances of Graph.
    *     2)  Function dijkstra(Graph&,int) finds a path through "graph" starting
    *         at vertex "startingIndex".
    */
    class BunchOfGraphs {
    
       enum Input_Format {	SINGLE_GRAPH_WITH_ROW_COLUMN, 
                               MULTIPLE_GRAPHS_WITH_COLUMN_WIDTH_ONLY};
    
       public:      
          BunchOfGraphs(const std::string& filename);      
          std::string dijkstra(Graph& graph, int startIndex) const;
    
       private:
          std::vector<Graph> graphContainer;
          std::string filename;
    
          bool retrieveData(const char* filename);
          bool retrieveData2(const char* filename, 
              enum Input_Format inputType = SINGLE_GRAPH_WITH_ROW_COLUMN);
          void output(const std::string& data, 
             const std::string& filename = "output.txt") const;
    };
    
    #endif // BUNCHOFGRAPHS_H_









    /******************************************************************************
    *  File: bunchofgraphs.cpp
    *  Author:  Vaddanak Seng
    *  Purpose: This is the implementation of class BunchOfGraphs.  It holds
    *     a collection of graph instances and provides Dijkstra algorithm to 
    *     find a path through a graph.      
    ******************************************************************************/
    
    #include "bunchofgraphs.h"
    
    #include <fstream> //ifstream, ofstream
    #include <iostream>
    #include <exception>
    #include <sstream>
    #include <algorithm>
    
    //file-scope global variables
    static bool debug = false;
     
    /**
    * Purpose: This constructs a BunchOfGraph object.
    * Precondition: "filename" is name of input file that has graph data.
    *     It is default to "input.txt"
    * Postcondition: Object of type BunchOfGraphs has been constructed.
    */
    BunchOfGraphs::BunchOfGraphs(const std::string& filename) : 
       filename(filename)
    {
       const int START_INDEX = 0; //path starts at this vertex index
       //retrieveData(filename.c_str());
       retrieveData2(filename.c_str());
          
       std::stringstream ss;
       size_t numberOfGraphs = graphContainer.size();
       for(size_t i = 0; i &lt; numberOfGraphs; ++i) {
          ss &lt;&lt;dijkstra(graphContainer[i],START_INDEX);
          if(ss.str().size() && ((i+STEP) &lt; numberOfGraphs))
             ss &lt;&lt;std::endl &lt;&lt;std::endl;      
       }   
       output(ss.str());   
    }
    
    /**
    * Purpose: This output data to file.
    * Precondition: "data" is data to output.  "filename" is name of output file,
    *     which is default to "seng.txt"
    * Postcondition: "data" has been written to file.
    */
    void BunchOfGraphs::output(const std::string& data, 
                               const std::string& filename) const 
    {
       std::ofstream output(filename.c_str());
       if(output && data.size()) {
          output &lt;&lt;data;
          output.close();  
       }      
    }
         
    /**
    * Purpose: This retrieves graph data from file and create instances of Graph.
    * Precondition: "filename" is the name of the file that contains graph data.
    * Postcondition: True is returned if instances of Graph has been created
    *     successfully; otherwise, false is returned.
    */
    bool BunchOfGraphs::retrieveData(const char* filename) {   
       debug = false;
       
       std::ifstream input(filename);
       if(!input) {
          std::cerr &lt;&lt;"Fail to open file: " &lt;&lt;filename &lt;&lt;std::endl;
          return false;         
       }   
       
       int numberOfGraphs = 0;       
       if(!(input >>numberOfGraphs)) {
          std::cerr &lt;&lt;"Fail to read numberOfGraphs" &lt;&lt;std::endl;
          return false;         
       }    
             
       //retrieve all graph instances from file and add to vector container
       for(int j = 0, widthOfGraph = 0; j &lt; numberOfGraphs; ++j) {      
          if(!(input >>widthOfGraph)) { //retrieve a graph width
             std::cerr &lt;&lt;"Fail to read widthOfGraph" &lt;&lt;std::endl;
             return false;         
          }              
          Graph graph(widthOfGraph); //create Graph object
          int numberOfElements = widthOfGraph * widthOfGraph;
          try { //populate Graph object with data
             for(int i = 0; i &lt; numberOfElements; ++i) 
                input >>graph[i];            
          }      
          catch(MyBad err) {
             std::cerr &lt;&lt;"Fail to populate graph data.\n" &lt;&lt;err.what() &lt;&lt;std::endl;
             return false;
          }
          graphContainer.push_back(graph); //add Graph object to container  
          //graph.showDataStore();       
       }   
       input.close(); //close file    
       
       if(debug) {
          std::cout &lt;&lt;numberOfGraphs &lt;&lt;std::endl;      
          for( std::vector<Graph>::iterator iter = graphContainer.begin(); 
               iter != graphContainer.end(); ++iter)
             //(*iter).showDataStore();  
             iter->showAdjacencyList();                         
       }                
       return true;
    }
    
    bool BunchOfGraphs::retrieveData2(const char* filename, 
        enum Input_Format inputType) {
        
        debug = false;
       
           std::ifstream input(filename);
           if(!input) {
              std::cerr &lt;&lt;"Fail to open file: " &lt;&lt;filename &lt;&lt;std::endl;
              return false;         
          }   
       
           int numberOfGraphs = 0;
       
           if(inputType == MULTIPLE_GRAPHS_WITH_COLUMN_WIDTH_ONLY) {     
               if(!(input >>numberOfGraphs)) {
                  std::cerr &lt;&lt;"Fail to read numberOfGraphs" &lt;&lt;std::endl;
                  return false;         
               }    
                 
               //retrieve all graph instances from file and add to vector container
               for(int j = 0, widthOfGraph = 0; j &lt; numberOfGraphs; ++j) {      
                  if(!(input >>widthOfGraph)) { //retrieve a graph width
                     std::cerr &lt;&lt;"Fail to read widthOfGraph" &lt;&lt;std::endl;
                     return false;         
                  }              
                  Graph graph(widthOfGraph); //create Graph object
                  int numberOfElements = widthOfGraph * widthOfGraph;
                  try { //populate Graph object with data
                     for(int i = 0; i &lt; numberOfElements; ++i) 
                        input >>graph[i];            
                  }      
                  catch(MyBad err) {
                     std::cerr &lt;&lt;"Fail to populate graph data.\n" &lt;&lt;err.what() &lt;&lt;std::endl;
                     return false;
                  }
                  graphContainer.push_back(graph); //add Graph object to container  
                  //graph.showDataStore();       
               }   
       
       }
       else if(inputType == SINGLE_GRAPH_WITH_ROW_COLUMN) {
               
               int row, column;   			
            numberOfGraphs = 1;
                 
               //retrieve all graph instances from file and add to vector container
           
              if(!(input >>row >>column)) { //retrieve a graph row and column
                 std::cerr &lt;&lt;"Fail to read row and column values" &lt;&lt;std::endl;
                 return false;         
              }              
              Graph graph(row,column); //create Graph object
              int numberOfElements = row * column;
              try { //populate Graph object with data
                 for(int i = 0; i &lt; numberOfElements; ++i) 
                    input >>graph[i]; //store distance values in array           
              }      
              catch(MyBad err) {
                 std::cerr &lt;&lt;"Fail to populate graph data.\n" &lt;&lt;err.what() &lt;&lt;std::endl;
                 return false;
              }
              graphContainer.push_back(graph); //add Graph object to container  
              //graph.showDataStore();       
           
           }
       
           input.close(); //close file    
       
           if(debug) {
              std::cout &lt;&lt;numberOfGraphs &lt;&lt;std::endl;      
              for( std::vector<Graph>::iterator iter = graphContainer.begin(); 
                   iter != graphContainer.end(); ++iter)
                 //(*iter).showDataStore();  
                 iter->showAdjacencyList();                         
           }                
           return true;	
    }
    
    /**
    * Purpose: Algorithm finds a path from startIndex to goal.
    * Precondition: "graph" is an instance of Graph.  "startIndex" is the index
    *     of the starting vertex.
    * Postcondition: A string containing direction to goal vertex is returned.
    */
    std::string BunchOfGraphs::dijkstra(Graph& graph, int startIndex) const {
       debug = true;    
       
       std::vector<Vertex>& vertices = graph.getVertexSet();     
       
       //setup collection of vertices ordered based on distance
       std::vector<Vertex*> onlyVertexPointers(vertices.size(),NULL);
       for(size_t i = 0; i &lt; vertices.size(); ++i)
          onlyVertexPointers[i] = &vertices[i];
          
       //setup starting vertex        
       if(onlyVertexPointers.size())
          onlyVertexPointers[startIndex]->setDistance(0);      
             
       //setup empty queue to hold path vertices
       std::queue<Vertex*> verticesQueue;
             
       //sort collection of vertices based on distance         
       std::make_heap<std::vector<Vertex*>::iterator,Vertex> 
          (onlyVertexPointers.begin(), onlyVertexPointers.end(), Vertex());
       std::sort_heap<std::vector<Vertex*>::iterator,Vertex>
          (onlyVertexPointers.begin(), onlyVertexPointers.end(), Vertex());
       //process each vertex 
       while(onlyVertexPointers.size()) {      
          std::make_heap<std::vector<Vertex*>::iterator,Vertex> 
             (onlyVertexPointers.begin(), onlyVertexPointers.end(), Vertex());
          std::pop_heap<std::vector<Vertex*>::iterator,Vertex>
             (onlyVertexPointers.begin(),onlyVertexPointers.end(),Vertex()); 
          Vertex* vptr = onlyVertexPointers.back();//get minimum
          onlyVertexPointers.pop_back();//remove min from collection of vertices
          
          verticesQueue.push(vptr);//add to queue
          //visit its adjacent neighbors          
          Vertex* temp = NULL;       
          const std::vector<Vertex*>& setOfAdjacentVertices = 
             vptr->getSetOfAdjacentVertices();
          for(size_t i = 0; i &lt; setOfAdjacentVertices.size(); ++i) {
             temp = setOfAdjacentVertices[i];
             Edge edge(vptr->getId(),temp->getId());
             const Edge* edgePtr = graph.findEdge(edge);         
             
             int edgeDistance = edgePtr?edgePtr->getDistance():0;
             int tempDistance = temp->getDistance();
             if(tempDistance&lt;0) tempDistance *= -1; //make positive
             int parentDistance = vptr->getDistance();
             if(parentDistance&lt;0) parentDistance *= -1; //make positive
                     
             if(edgePtr && (tempDistance > parentDistance + edgeDistance) ) {
                temp->setDistance(parentDistance + edgeDistance);
                temp->setParent(vptr);            
             }         
          }      
          std::make_heap<std::vector<Vertex*>::iterator,Vertex> 
             (onlyVertexPointers.begin(), onlyVertexPointers.end(), Vertex());
          std::sort_heap<std::vector<Vertex*>::iterator,Vertex>
             (onlyVertexPointers.begin(), onlyVertexPointers.end(), Vertex());
       }   
       //graph.displayVertexSetPointers(onlyVertexPointers);
       //graph.displayVertexSet();
       //graph.displayEdgeSet();   
       
       /*
       std::queue<Vertex*> testpath(verticesQueue);
       while(!testpath.empty()) {
            std::cout &lt;&lt;((testpath.front())->getId()) &lt;&lt;" ";
            testpath.pop();
        }	
       std::cout &lt;&lt;std::endl;   		
       */    
       
       //retrieves the successful path
       std::vector<int> successPath;
       int find = graph.getRow() * graph.getColumn() - 1; //goalIndex   
       successPath.push_back(find);   
       const Vertex* vptr = NULL;
       while(find != startIndex) {
          vptr = vertices[find].getParent();
          if(!vptr) {
             std::cerr &lt;&lt;"ERROR?  Parent is NULL!" &lt;&lt;std::endl;
             break;
          }
          find = vptr->getId();  
          successPath.push_back(find);                  
       }   
       
       //display path using vertex index
       if(debug) {
          std::cout &lt;&lt;"STARTING VERTEX: " &lt;&lt;startIndex &lt;&lt;std::endl;
          std::cout &lt;&lt;"Path by vertex index: ";
          std::vector<int>::reverse_iterator 
             riter = successPath.rbegin(),
             rstop = successPath.rend();
          for( ; riter != rstop; ++riter)      
             std::cout &lt;&lt;(*riter % (graph.getWidth()*graph.getWidth()))&lt;&lt;" ";
          std::cout &lt;&lt;std::endl;         
       }        
          
       //display path using symbols: W E N S NW NE SW SE   
       std::stringstream ss;
       for(std::vector<int>::reverse_iterator riter = successPath.rbegin(); 
          riter != successPath.rend(); ++riter) 
       {             
          if( (riter + 1) != successPath.rend() ) {
             ss &lt;&lt;graph.determineDirection(*riter,*(riter+1));
             if( (riter + 2) != successPath.rend() )
                ss &lt;&lt;" "; 
          }            
          else             
             break;   
       }    
         
       if(debug) 
          std::cout &lt;&lt;"Path by direction: " &lt;&lt;ss.str() &lt;&lt;std::endl &lt;&lt;std::endl;  
          
       return ss.str();
    }










    /******************************************************************************
    *  File: graph.h
    *  Author:  Vaddanak Seng
    *  Purpose: Header file contains definition of Graph, Node, Edge, and
    *     MyBad classes.
    ******************************************************************************/
    
    #ifndef GRAPH_H_
    #  define GRAPH_H_
    
    #include <string>
    #include <exception>
    #include <vector>
    //#include <climits> //INT_MAX
    
    //forward declaration
    class Node;
    class MyBad;
    class Graph;
    class Edge;
    
    typedef class Node Vertex;
    
    //global variables
    static const int DISTMAX = 88888;
    static const int FACTOR = 1000;
    static const int ERR_VALUE = -1;
    static const int NULL_ZERO = 0;
    static const int TWO = 2;
    static const int STEP = 1;
    
    enum Direction { WEST, EAST, NORTH, SOUTH, NORTHWEST, NORTHEAST, 
                     SOUTHWEST, SOUTHEAST};
    
    /**
    * Purpose:  Class Graph represents a graph using an adjacency list.  It is also
    *     represented by a set of vertices and set of edges.
    * How-to-use:
    *     1)  Default constructor is used to initialize collection of graphs.
    *     2)  Graph(int) constructs a graph with a specified side length.
    *     3)  The operator[](int) allows access to graph data at specified index.
    *     4)  The operator()(int) allows access to graph vertex at specified index.
    *     5)  You can retrieve set of graph vertices using function getVertexSet().
    *     6)  You can retrieve set of graph edges using function getEdgeSet().
    *     7)  Function findEdge(const Edge&) returns a pointer to a unique Edge
    *         object in the edgeSet if it exists.
    *     8)  Functions show... and display... output content to console for
    *         debugging usages.
    *     9)  Function getWidth() returns side lenght of graph and
    *         getAdjacencySize() returns number of elements in adjacencyList.
    *    10)  Function determineDirection(int,int) gives W, E, N, S, NW, NE, SW,
    *         or SE direction when moving from startingIndex to endingIndex.
    */
    class Graph {
       public:
          Graph();
          Graph(const int row, const int column);
          Graph(const int& width);
          Graph(const Graph& rhs);
          ~Graph();
          Graph& operator=(const Graph& rhs);
          //access element at "index" in "dataStore" array
          int& operator[](const int& index);      
          //access linked list at "index" in "adjacencyList" array 
          const Node* operator()(int index) const; 
          
          std::vector<Vertex>& getVertexSet();
          const std::vector<Edge>& getEdgeSet() const;
          const Edge* findEdge(const Edge& lookFor) const; 
          std::string determineDirection(int start, int end) const;
          
          void showDataStore() const;
          void showAdjacencyList() const;      
          void displayVertexSet() const;
          void displayEdgeSet() const;
          void displayVertexSetPointers(const std::vector<Vertex*>&) const;
          
          int getWidth() const;
          int getRow() const;
          int getColumn() const;
          int getAdjacencySize() const;     
       
       private:
             int row, column;
          int width; // n
          int numberOfElements; // n * n
          int * dataStore; // n * n memory allocation; holds input table values      
          int adjacencyArraySize; // 2 * n * n ; useful for diagonal moves
          //each element in vector container is a linked list to adjacent vertices;
          //"next" pointer links the vertices in the linked list; "parent" pointer
          //is not used here
          std::vector<Node> adjacencyList;          
          //collection of vertices; "next" pointer is always NULL here; "parent"
          //pointer points to another element in the vector
          std::vector<Vertex> vertexSet; 
          std::vector<Edge> edgeSet; //collection of edges; distances are positive
    
          //helper functions            
          void initializeDataStore();
          void removeDataStore();
          int* createDataStore();
          void copyDataStore(const int* sourceData);
          void removeAdjacencyList();
          void removeAdjacencyList2();
          void createAdjacencyList();
          void addNode(int rootIndex, int targetIndex);
          int determineAdjacencyArrayIndex( int currentIndex, 
                                            enum Direction direction);
          void populateVertexSet();
          void populateEdgeSet();                                             
    };
    
    /**
    * Purpose:  Class Node represents the vertex in a graph.
    * How-to-use:
    *     1)  Default constructor initializes all data members.
    *     2)  Once default Node object is created, you can set the distance, id,
    *         and parent data members using the corresponding set... functions.
    *     3)  The get... functions will return the corresponding distance, id,
    *         and parent data members.
    *     4)  Calling getSetOfAdjacentVertices() returns a vector container that
    *         holds pointers to vertices adjacent to this vertex.
    *     5)  operator()(const Node*, const Node*) allows two Node objects to be
    *         compared based on distance values.
    */
    class Node {  
       public:
          Node() : distance(DISTMAX), id(ERR_VALUE), next(NULL), 
                   parent(NULL), vertexPointers(NULL_ZERO,NULL) 
          {}     
          
          void setDistance(const int& distance);
          void setId(const int& id);
          void setParent(Node* parent);
          
          int getDistance() const;      
          int getId() const;      
          const Node* const getParent() const;
          const std::vector<Vertex*>& getSetOfAdjacentVertices() const;
          
          bool operator()(const Node* n1, const Node* n2) const;      
          
       private:
          int distance;
          int id; // location index between 0 to (n x n - 1)
          Node* next; //root is element of adjacency list array     
          Node* parent;
          //pointers in list refer to nodes in same vertex set
          std::vector<Vertex*> vertexPointers;//holds pointers to adjacent vertices
          friend class Graph;
    };
    
    /**
    * Purpose:  Class Edge represents the edge between two vertices in a graph.
    * How-to-use:
    *     1)  Default constructor initializes all data members, which is mainly
    *         useful for a container class.
    *     2)  You should use Edge(int,int,int) to construct Edge object with
    *         source, destination, and distance arguments.
    *     3)  Function hash(int,int) creates a hashcode unique for each different
    *         pair of vertices.
    *     4)  Function compare(const Edge&,const Edge&) provides equality
    *         comparison based on hashCode.
    *     5)  Function operator()(const Edge&,const Edge&) provides less-than
    *         comparison based on hashCode.
    *     6)  The get... functions will return corresponding source index,
    *         destination index, distance, and hashCode.
    */
    class Edge {
       public:
          Edge() : _source(NULL_ZERO), _destination(NULL_ZERO), _distance(DISTMAX)
          {
             _hashCode = hash(_source, _destination);
          }
       
          Edge(int source, int destination, int distance=DISTMAX) :
             _source(source), _destination(destination), _distance(distance)
          {
             _hashCode = hash(_source, _destination);
          }     
          
          static int hash(int source, int destination);      
          static bool compare(const Edge& e1, const Edge& e2);
          bool operator()(const Edge& e1, const Edge& e2) const;
          
          int getSource() const;
          int getSource(const int& hashCode) const;
          int getDestination() const;
          int getDistance() const;
          int getHashCode() const;     
       
       private:
          int _source; // location index between 0 to (n x n - 1)
          int _destination; // location index between 0 to (n x n - 1)
          int _distance; // weight between source vertex and destination vertex
          int _hashCode;      
    };
    
    /**
    * Purpose:  Class MyBad is a custom exception type, which is used for various
    *     possible erroneous occurrences.
    * How-to-use:
    *     1)  You should use constructor MyBad(const string&) with custom message.
    *     2)  If this type was thrown and caught, you should call what() to get
    *         hint on cause of error.
    */
    class MyBad : public std::exception {
       public:
          MyBad(const std::string& msg) : msg(msg) {}
          const char* what() const throw();
          ~MyBad() throw() {}
       private:
          std::string msg;
    };
    
    #endif // GRAPH_H_










    /******************************************************************************
    *  File: graph.cpp
    *  Author:  Vaddanak Seng
    *  Purpose: This is the implementation file for classes Graph, Node, Edge,
    *     and MyBad.  Graph represents a graph instance.  Node or Vertex
    *     represents each vertex in the graph.  Edge represents a directed arc
    *     between a pair of vertices.  MyBad is a custom exception type used in
    *     throw statement to indicate some kind of error.
    ******************************************************************************/
    
    #include "graph.h"
    
    #include <iostream>
    #include <iomanip>
    #include <sstream>
      
    //file-scope variables 
    static bool debug = false;
    static const char * INFINITY = "\u221E";
    
    /*======= class Graph implementation =======*/ 
    
    /**
    * Purpose: This creates a default object with data members properly
    *     initialized.  It is mainly useful for containers.
    * Precondition: Memory is allocated.
    * Postcondition: Instance of Graph type is created with members initialized.     
    */
    Graph::Graph() : row(NULL_ZERO), column(NULL_ZERO),
                     width(NULL_ZERO), numberOfElements(NULL_ZERO),
                     dataStore(NULL),                 
                     adjacencyArraySize(NULL_ZERO), 
                     adjacencyList(adjacencyArraySize),
                     vertexSet(adjacencyArraySize)
    {}
     
    /**
    * Purpose: This creates a Graph object with the specified dimension.  Graph
    *     is expected to be a square.
    * Precondition: Memory is allocatd.
    * Postcondition: Instance of Graph type is created with members initialized.
    */
    Graph::Graph(const int& width) : row(width), column(width),
                                     width(width), numberOfElements(width*width),
                                     dataStore(NULL),
                                     adjacencyArraySize(TWO*numberOfElements),
                                     adjacencyList(adjacencyArraySize),
                                     vertexSet(adjacencyArraySize) 
    {
       createDataStore();        
       createAdjacencyList();
       populateVertexSet();
       populateEdgeSet();
    }
    
    Graph::Graph(const int row, const int column) :
                                     row(row), column(column),
                                     width(column), numberOfElements(row*column),
                                     dataStore(NULL),
                                     adjacencyArraySize(TWO*numberOfElements),
                                     adjacencyList(adjacencyArraySize),
                                     vertexSet(adjacencyArraySize) 
    {
       createDataStore();        
       createAdjacencyList();
       populateVertexSet();
       populateEdgeSet();
    }
    
    /**
    * Purpose: This creates a Graph object that is a copy of passed-in argument.
    * Precondition: Memory is allocated.
    * Postcondition: Copy of "rhs" is created.
    */
    Graph::Graph(const Graph& rhs) : row(NULL_ZERO), column(NULL_ZERO),
                                     width(NULL_ZERO), numberOfElements(NULL_ZERO), 
                                     dataStore(NULL),
                                     adjacencyArraySize(NULL_ZERO),
                                     adjacencyList(adjacencyArraySize),
                                     vertexSet(adjacencyArraySize)
    {
       operator=(rhs);
    } 
    
    /**
    * Purpose: Destructor releases allocated memory.
    * Precondition: Object is valid.
    * Postcondition: Resources have been released.
    */
    Graph::~Graph() {  
       removeDataStore();     
       removeAdjacencyList();
    }
      
    /**
    * Purpose: This copies "rhs" content into "this" object content.
    * Precondition: Object is valid.
    * Postcondition: This object contains same content as "rhs".
    */
    Graph& Graph::operator=(const Graph& rhs) {   
       if(this != &rhs) {
          removeDataStore();        
          removeAdjacencyList();        
        
          row = rhs.row;
          column = rhs.column;
          width = rhs.width;
          numberOfElements = rhs.numberOfElements; 
          adjacencyArraySize = rhs.adjacencyArraySize;  
          adjacencyList.resize(adjacencyArraySize);     
          vertexSet.resize(adjacencyArraySize);       
          
          createDataStore();
          copyDataStore(rhs.dataStore); 
                
          createAdjacencyList();
          populateVertexSet();
          populateEdgeSet();
       }
       return *this;
    }
    
    /**
    * Purpose: This provides access to the set of vertices of this graph.
    * Precondition: Graph object is valid.
    * Postcondition: A set of vertices is returned.
    */
    std::vector<Vertex>& Graph::getVertexSet() {
       return vertexSet; 
    }
    
    /**
    * Purpose: This provides access to the set of directed arcs/edges between
    *     pairs of vertices in this graph.
    * Precondition: Graph object is valid.
    * Postcondition: A set of arcs/edges is returned.
    */
    const std::vector<Edge>& Graph::getEdgeSet() const {
       return edgeSet; 
    }
    
    /**
    * Purpose: This provides the side length of the square graph.
    * Precondition: Graph object is valid.
    * Postcondition: The side length of the graph is returned.
    */
    int Graph::getWidth() const { 
       return width; 
    }
    
    int Graph::getRow() const { 
       return row; 
    }
    
    int Graph::getColumn() const { 
       return column; 
    }
    
    /**
    * Purpose: This gives the number of elements in the adjacent list container,
    *     which is 2*width*width.
    * Precondition: Graph object is valid.
    * Postcondition: The number of adjacent-list elements is returned.
    */
    int Graph::getAdjacencySize() const { 
       return adjacencyArraySize; 
    }
    
    /**
    * Purpose: This displays the graph data as obtained from input.txt file.
    * Precondition: Graph object is valid.
    * Postcondition: Graph data is displayed to console.
    */
    void Graph::showDataStore() const {
       debug = true;
       const int WIDTH = 4;
    
       if(dataStore) {
          std::cout &lt;&lt;"\nGraph dataStore ..." &lt;&lt;std::endl;
          for(int i = 0; i &lt; numberOfElements ; ) {
             std::cout &lt;&lt;std::setw(WIDTH) &lt;&lt;dataStore[i++];
             if( !(i%width) )
                std::cout &lt;&lt;std::endl;
          }
          std::cout &lt;&lt;std::endl;   
       }
    
    }
    
    /**
    * Purpose: This allows access to graph data.
    * Precondition: "index" is between 0 to width*width-1.
    * Postcondition: A reference to graph data at "index" location is returned if
    *     index is valid; otherwise, it throws MyBad.
    */
    int& Graph::operator[](const int& index) {
       if(!dataStore) //array not available
          throw MyBad("Array dataStore is NULL");
       if(index &lt; 0 || index >= numberOfElements) { //index is out of bounds
          std::stringstream ss;
          ss &lt;&lt;"Index is out of bounds. Must be between 0 and less than ";      
          ss &lt;&lt;numberOfElements &lt;&lt; ".";
          throw MyBad(ss.str());     
       }          
       return dataStore[index];
    }
    
    /**
    * Purpose: This allows access to vertices contained in adjacency list.
    * Precondition: "index" is between 0 to 2*width*width-1.
    * Postcondition: If "index" is valid, pointer to a vertex at "index" location
    *     is returned; otherwise, it returns NULL.
    */
    const Node* Graph::operator()(int index) const {   
       if(!adjacencyList.size()) //array not available      
          return NULL;         
       if(index &lt; 0 || index >= adjacencyArraySize) { //index is out of bounds      
          return NULL;
       }             
       return &adjacencyList[index];
    }
    
    /**
    * Purpose: This allocates and initializes memory for graph data.
    * Precondition: Graph object is valid.
    * Postcondition: Memory has been allocated for dataStore and initialized.
    */
    int* Graph::createDataStore() {   
       dataStore = new int[numberOfElements];
       if(!dataStore) { //make sure allocate is good
          std::cerr &lt;&lt;"Fail to allocate memory" &lt;&lt;std::endl;
       }
       //initialize array for graph elements
       for(int i = 0; i &lt; numberOfElements; ++i)
          dataStore[i] = NULL_ZERO;
       
       return dataStore;
    }
    
    /**
    * Purpose: This displays content of adjacency list to console.
    * Precondition: Graph object is valid.
    * Postcondition: Content of adjacency list is displayed to console.
    */
    void Graph::showAdjacencyList() const {
       if(adjacencyList.size()) {
          std::cout &lt;&lt;"\nAdjacency list ..." &lt;&lt;std::endl;
          std::stringstream ss;
          for(size_t i = 0; i &lt; adjacencyList.size(); ++i) {
             ss.str() = "";
             ss &lt;&lt;"[i=" &lt;&lt;adjacencyList[i].getId() 
                &lt;&lt;",d=" &lt;&lt;adjacencyList[i].getDistance()
                &lt;&lt;"] -> ";
             Node* temp = adjacencyList[i].next;
             while(temp) {            
                ss &lt;&lt;"[i=" &lt;&lt;temp->getId() &lt;&lt;",d="; 
                temp->getDistance() &lt; DISTMAX ?
                   ss &lt;&lt;temp->getDistance() : ss &lt;&lt;INFINITY;
                ss &lt;&lt;"] -> ";
                temp = temp->next;                      
             }   
             ss &lt;&lt;"NULL" &lt;&lt;std::endl;    
          }
          std::cout &lt;&lt;ss.str() &lt;&lt;std::endl;   
       }
    }
    
    /**
    * Purpose: This copies graph data from "sourceData" into "this" dataStore.
    * Precondition: "sourceData" is a pointer to source graph data location.
    * Postcondition: Graph's "dataStore" is filled with a copy of "sourceData"
    */
    void Graph::copyDataStore(const int* sourceData) {
       if(dataStore && sourceData)  
          for(int i = 0; i &lt; numberOfElements ; ++i)
             dataStore[i] = sourceData[i];         
    }
    
    /**
    * Purpose: This deletes memory allocated for "dataStore"
    * Precondition: Graph object is valid.
    * Postcondition: "dataStore" allocation has been deleted.
    */
    void Graph::removeDataStore() {
       if(dataStore) {
          delete[] dataStore;
          dataStore = NULL;
       }       
    }
       
    /**
    * Purpose: This creates the adjacency list.
    * Precondition: Graph object is valid.
    * Postcondition: Adjacency list is created containing vertices and associated
    *     linked-list of adjacent vertices.
    */
    void Graph::createAdjacencyList() {   
       //populate adjacencyList array with Node objects   
       int vSize = static_cast<int>(adjacencyList.size());
       for(int i = 0; i &lt; vSize; ++i) {     
          adjacencyList[i].setId(i);
          adjacencyList[i].setDistance(dataStore[i%numberOfElements]);         
       }     
       
       //for each element at index 0 to n*n-1; horizontal/vertical part
       //check left, right, above, and below
       //if negative, check diagonals in diagonal part
       
       //populate linked-list per array element with adjacent Node objects
       for(int i = 0, index; i &lt; vSize; ++i) {
          //leave the goal vertices alone
          if(i == numberOfElements - STEP || i == TWO*numberOfElements-STEP)
             continue;
             
          index = determineAdjacencyArrayIndex(i,WEST);
          if(index > ERR_VALUE) addNode(i,index);     
             
          index = determineAdjacencyArrayIndex(i,EAST);
          if(index > ERR_VALUE) addNode(i,index);       
          
          index = determineAdjacencyArrayIndex(i,NORTH);
          if(index > ERR_VALUE) addNode(i,index); 
          
          index = determineAdjacencyArrayIndex(i,SOUTH);
          if(index > ERR_VALUE) addNode(i,index);   
          
          index = determineAdjacencyArrayIndex(i,NORTHWEST);
          if(index > ERR_VALUE) addNode(i,index);
          
          index = determineAdjacencyArrayIndex(i,NORTHEAST);
          if(index > ERR_VALUE) addNode(i,index);
          
          index = determineAdjacencyArrayIndex(i,SOUTHWEST);
          if(index > ERR_VALUE) addNode(i,index);
          
          index = determineAdjacencyArrayIndex(i,SOUTHEAST);
          if(index > ERR_VALUE) addNode(i,index);         
       }     
    }
    
    /**
    * Purpose: This gives the index of the vertex adjacent to current vertex.
    * Precondition: "currentIndex" refers to the reference vertex.  "direction"
    *     refers to W, E, N, S, NW, NE, SW, or SE direction of adjacent vertex
    *     with respect to reference vertex.
    * Postcondition: The index of the adjacent vertex that lies "direction"
    *     of the reference vertex is returned.
    */
    int Graph::determineAdjacencyArrayIndex( int currentIndex,  
                                             enum Direction direction) {      
       int index = ERR_VALUE;   
       int diagonalStartIndex = numberOfElements; 
       
       int row, column; // base on width x width array; so can be 0 to width-1
       /*
       if(currentIndex &lt; diagonalStartIndex) {
          row = currentIndex / width;
          column = currentIndex % width;
       }
       else {
          row = (currentIndex - diagonalStartIndex) / width;
          column = (currentIndex - diagonalStartIndex) % width;
       }     
       */     
       if(currentIndex &lt; diagonalStartIndex) {
          row = currentIndex / this->row;
          column = currentIndex % this->column;
       }
       else {
          row = (currentIndex - diagonalStartIndex) / this->row;
          column = (currentIndex - diagonalStartIndex) % this->column;
       }       
      
       int elementDistance = adjacencyList[currentIndex].getDistance();  
       switch(direction) {
          case WEST:
             if(elementDistance &lt; 0) { //negative moves
                elementDistance *= -1; //make positive
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   index = ERR_VALUE; //cannot move horizontal/vertical
                }
                else { // for diagonal part
                   column = column - elementDistance;               
                   if(column &lt; 0)
                      index = ERR_VALUE;
                   else
                      index = row * width + column;                  
                }
             }
             else { //positive moves
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   column = column - elementDistance;
                   if(column &lt; 0)
                      index = ERR_VALUE;
                   else
                      index = row * width + column;                  
                }
                else { // for diagonal part
                   index = ERR_VALUE;
                }         
             }
             break;
          case EAST:
             if(elementDistance &lt; 0) { //negative moves
                elementDistance *= -1; //make positive
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   index = ERR_VALUE; //cannot move horizontal/vertical
                }
                else { // for diagonal part
                   column = column + elementDistance;
                   if(column &lt; width) 
                      index = row * width + column;
                   else
                      index = ERR_VALUE;             
                }
             }
             else { //positive moves
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   column = column + elementDistance;
                   if(column &lt; width)
                      index = row * width + column;
                   else
                      index = ERR_VALUE;
                }
                else { // for diagonal part
                   index = ERR_VALUE;
                }         
             }
             break;
          case NORTH:
             if(elementDistance &lt; 0) { //negative moves
                elementDistance *= -1; //make positive
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   index = ERR_VALUE; //cannot move horizontal/vertical
                }
                else { // for diagonal part
                   row = row - elementDistance;
                   if(row &lt; 0) 
                      index = ERR_VALUE;
                   else
                      index = row * width + column;             
                }
             }
             else { //positive moves
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   row = row - elementDistance;
                   if(row &lt; 0)
                      index = ERR_VALUE;
                   else
                      index = row * width + column;
                }
                else { // for diagonal part
                   index = ERR_VALUE;
                }         
             }
             break;
          case SOUTH:
             if(elementDistance &lt; 0) { //negative moves
                elementDistance *= -1; //make positive
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   index = ERR_VALUE; //cannot move horizontal/vertical
                }
                else { // for diagonal part
                   row = row + elementDistance;
                   if(row &lt; width) 
                      index = row * width + column;
                   else
                      index = ERR_VALUE;             
                }
             }
             else { //positive moves
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   row = row + elementDistance;
                   if(row &lt; width)
                      index = row * width + column;
                   else
                      index = ERR_VALUE;
                }
                else { // for diagonal part
                   index = ERR_VALUE;
                }         
             }
             break;
          case NORTHWEST:
             if(elementDistance &lt; 0) { //negative moves
                elementDistance *= -1; //make positive
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   row = row - elementDistance;
                   column = column - elementDistance;
                   if(row&lt;0 || column&lt;0)
                      index = ERR_VALUE;
                   else
                      index = row * width + column + diagonalStartIndex;                  
                }
                else { // for diagonal part
                   index = ERR_VALUE;          
                }
             }
             else { //positive moves
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   index = ERR_VALUE;
                }
                else { // for diagonal part
                   row = row - elementDistance;
                   column = column - elementDistance;
                   if(row&lt;0 || column&lt;0)
                      index = ERR_VALUE;
                   else
                      index = row * width + column + diagonalStartIndex;                  
                }         
             }
             break;
          case NORTHEAST:
             if(elementDistance &lt; 0) { //negative moves
                elementDistance *= -1; //make positive
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   row = row - elementDistance;
                   column = column + elementDistance;
                   if(row&lt;0 || column>=width)
                      index = ERR_VALUE;
                   else
                      index = row * width + column + diagonalStartIndex;                  
                }
                else { // for diagonal part
                   index = ERR_VALUE;             
                }
             }
             else { //positive moves
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   index = ERR_VALUE;
                }
                else { // for diagonal part
                   row = row - elementDistance;
                   column = column + elementDistance;
                   if(row&lt;0 || column>=width)
                      index = ERR_VALUE;
                   else
                      index = row * width + column + diagonalStartIndex;                  
                }         
             }
             break;
          case SOUTHWEST:
             if(elementDistance &lt; 0) { //negative moves
                elementDistance *= -1; //make positive
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   row = row + elementDistance;
                   column = column - elementDistance;
                   if(row>=width || column&lt;0)
                      index = ERR_VALUE;
                   else
                      index = row * width + column + diagonalStartIndex;                  
                }
                else { // for diagonal part
                   index = ERR_VALUE;             
                }
             }
             else { //positive moves
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   index = ERR_VALUE;
                }
                else { // for diagonal part
                   row = row + elementDistance;
                   column = column - elementDistance;
                   if(row>=width || column&lt;0)
                      index = ERR_VALUE;
                   else
                      index = row * width + column + diagonalStartIndex;                  
                }         
             }
             break;
          case SOUTHEAST:
             if(elementDistance &lt; 0) { //negative moves
                elementDistance *= -1; //make positive
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   row = row + elementDistance;
                   column = column + elementDistance;
                   if(row&lt;width && column&lt;width)
                      index = row * width + column + diagonalStartIndex; 
                   else
                      index = ERR_VALUE;                  
                }
                else { // for diagonal part
                   index = ERR_VALUE;             
                }
             }
             else { //positive moves
                if(currentIndex &lt; diagonalStartIndex) { // for hor/vert part
                   index = ERR_VALUE;
                }
                else { // for diagonal part
                   row = row + elementDistance;
                   column = column + elementDistance;
                   if(row&lt;width && column&lt;width)
                      index = row * width + column + diagonalStartIndex; 
                   else
                      index = ERR_VALUE;                  
                }         
             }
             break;
          default:
             std::cerr &lt;&lt;"Unkown direction" &lt;&lt;std::endl;   
       }                                           
       return index; //negative index indicates impossible move                                        
    }                                        
    
    /**
    * Purpose: This creates a node for a vertex adjacent to reference vertex and
    *     adds node to reference vertex's linked list.
    * Precondition: "rootIndex" refers to reference vertex.  "targetIndex" refers
    *     to a vertex adjacent to the reference vertex.
    * Postcondition: An adjacent vertex has been added to reference vertex's
    *     linked-list.
    */
    void Graph::addNode(int rootIndex, int targetIndex) {
       Node* newNode = new Node;   
       if(!newNode) {
          std::cerr &lt;&lt;"Failed to allocate new node" &lt;&lt;std::endl;
          return;
       }   
       newNode->setId(targetIndex);   
       newNode->next = adjacencyList[rootIndex].next;
       
       adjacencyList[rootIndex].next = newNode;   
    }
    
    /**
    * Purpose: This deletes the linked list of adjacent vertices associated
    *     with each vertex.
    * Precondition: Graph object is valid.
    * Postcondition: Each vertex in adjacency list has no linked list.
    */
    void Graph::removeAdjacencyList() {
       Node* temp = NULL;
       for(size_t i = 0; i &lt; adjacencyList.size(); ++i) {//visit each array element
          while(adjacencyList[i].next) { //remove linked-list in array element
             temp = adjacencyList[i].next;
             adjacencyList[i].next = temp->next;
             delete temp;
          }
       }   
    }
    
    /**
    * Purpose: This sets up each vertex in the vertexSet.
    * Precondition: Graph object is valid.
    * Postcondition: Each vertex in vertexSet is properly setup.  Each vertex
    *     contains a set of pointers to its adjacent neighbors.  "next" and
    *     "parent" pointers are NULL.
    */
    void Graph::populateVertexSet() {   
       for(int i = 0; i &lt; adjacencyArraySize; ++i) {
          vertexSet[i].setId(i);
          const Vertex* vertexPtr = operator()(i); //get head node in adjacency list
          if(!vertexPtr) { //err: fail to access vertex
             std::cerr &lt;&lt;"Fail to access vertex in adjacencyList" &lt;&lt;std::endl;
             throw MyBad("Fail to populate vertexSet!");
          } 
          while(vertexPtr->next) {
             vertexPtr = vertexPtr->next;
             vertexSet[i].vertexPointers.push_back(&vertexSet[vertexPtr->getId()]);
          }
       }   
    }
    
    /**
    * Purpose: This sets up each edge in the EdgeSet.
    * Precondition: Graph object is valid.
    * Postcondition: "edgeSet" holds a set of edges representing each directed
    *     arc between two vertices in the graph.
    */
    void Graph::populateEdgeSet() {   
       const Vertex* temp = NULL;
       for(int i = 0; i &lt; adjacencyArraySize; ++i) {
          temp = operator()(i);//get vertex from adjacencyList at index i    
          if(!temp) { //err: fail to access vertex
             std::cerr &lt;&lt;"Fail to access vertex in adjacencyList" &lt;&lt;std::endl;
             throw MyBad("Fail to populate edgeSet!");
          } 
          int distance = temp->getDistance();
          if(distance&lt;0) distance *= -1; //make positive
          while(temp->next) {
             temp = temp->next;
             Edge edge(i,temp->getId(),distance);
             if(!findEdge(edge))
                edgeSet.push_back(edge);
          }
       }
    }
    
    /**
    * Purpose: This finds a matching edge that exists in "edgeSet".
    * Precondition: "lookFor" represents an edge that we want to find in edgeSet.
    * Postcondition: A pointer to a matching Edge object is returned; otherwise,
    *     NULL is returned if match was not found in edgeSet.
    */
    const Edge* Graph::findEdge(const Edge& lookFor ) const {
       for(size_t i = 0; i &lt; edgeSet.size(); ++i) {
          if( Edge::compare(edgeSet[i], lookFor) )
             return &edgeSet[i];
       }
       return NULL;
    }
    
    /**
    * Purpose: This displays set of vertices to console.
    * Precondition: Graph object is valid.
    * Postcondition: All vertices in vertexSet is displayed.
    */
    void Graph::displayVertexSet() const
    {
       std::cout &lt;&lt;"\nDisplay \"vertexSet\" content..." &lt;&lt;std::endl;
       const std::vector<Vertex>& vertices = vertexSet;
       int count = 0;
       for(size_t i = 0; i &lt; vertices.size(); ++i) {
          ++count;
          std::cout &lt;&lt;"[i=" &lt;&lt;vertices[i].getId() 
                    &lt;&lt;",d=" &lt;&lt;vertices[i].getDistance() 
                    &lt;&lt;",p=" ;
          vertices[i].parent?
             (std::cout &lt;&lt;(vertices[i].parent)->getId()&lt;&lt;"]"):
             (std::cout&lt;&lt;"NULL]");
          std::vector<Vertex*>::const_iterator 
             iter = vertices[i].vertexPointers.begin(),
             stop = vertices[i].vertexPointers.end();
          for( ; iter != stop; ++iter) {
             std::cout &lt;&lt;" -> [i=" &lt;&lt;(*iter)->getId()
                       &lt;&lt;",d=" &lt;&lt;(*iter)->getDistance()
                       &lt;&lt;",p=";
             ((*iter)->parent)?
                (std::cout&lt;&lt;(((*iter)->parent)->getId()) &lt;&lt;"]"):
                std::cout &lt;&lt;"NULL]";
          }           
          std::cout &lt;&lt;std::endl;
       }
       std::cout &lt;&lt;"Total number of vertices: " &lt;&lt;count &lt;&lt;std::endl;   
    }
    
    /**
    * Purpose: This displays set of edges to console.
    * Precondition: Graph object is valid.
    * Postcondition: All edges in edgeSet is displayed.
    */
    void Graph::displayEdgeSet() const {   
       std::cout &lt;&lt;"\nDisplay \"edgeSet\" content..." &lt;&lt;std::endl;
       const std::vector<Edge>& edges = edgeSet;
       std::vector<Edge>::const_iterator 
          iter = edges.begin(),
          stop = edges.end();     
       int count = 0;    
       for(int source = iter->getSource(), temp = 0 ; iter != stop; ++iter) {      
          ++count;
          temp = iter->getSource(iter->getHashCode()); 
          if(source != temp) {
             std::cout &lt;&lt;std::endl; 
             source = temp;        
          }               
          std::cout &lt;&lt;"[src=" &lt;&lt;iter->getSource() 
                    &lt;&lt;",dest=" &lt;&lt;iter->getDestination() 
                    &lt;&lt;",dist=" &lt;&lt;iter->getDistance() &lt;&lt;"]  ";
       }      
       std::cout &lt;&lt;"\nTotal number of edges: " &lt;&lt;count &lt;&lt;std::endl;   
    }
    
    /**
    * Purpose: This displays each vertex along with its adjacent vertices.
    * Precondition: "vertices" is a collection of pointers to each vertex in graph.
    * Postcondition: Each vertex and its adjacent neighbors is displayed.
    */
    void Graph::displayVertexSetPointers(const std::vector<Vertex*>& vertices)
       const
    {
       std::cout &lt;&lt;"\nDisplay \"vertexSetPointers\" content..." &lt;&lt;std::endl;
       int count = 0;
       for(size_t i = 0; i &lt; vertices.size(); ++i) {
          ++count;
          std::cout &lt;&lt;"[i=" &lt;&lt;vertices[i]->getId() 
                    &lt;&lt;",d=" &lt;&lt;vertices[i]->getDistance() 
                    &lt;&lt;",p=" ;
          vertices[i]->parent? 
             (std::cout &lt;&lt;(vertices[i]->parent)->getId()&lt;&lt;"]"):
             (std::cout&lt;&lt;"NULL]");
          std::vector<Vertex*>::const_iterator 
             iter = (vertices[i]->vertexPointers).begin(),
             stop = (vertices[i]->vertexPointers).end();
          for( ; iter != stop; ++iter) {
             std::cout &lt;&lt;" -> [i=" &lt;&lt;(*iter)->getId()
                       &lt;&lt;",d=" &lt;&lt;(*iter)->getDistance()
                       &lt;&lt;",p=";
             ((*iter)->parent)?
                (std::cout&lt;&lt;(((*iter)->parent)->getId()) &lt;&lt;"]"):
                std::cout &lt;&lt;"NULL]";
          }           
          std::cout &lt;&lt;std::endl;
       }
       std::cout &lt;&lt;"Total number of vertices: " &lt;&lt;count &lt;&lt;std::endl;   
    }
    
    /**
    * Purpose: This gives the direction of reference vertex to adjacent vertex.
    * Precondition: "startingIndex" refers to reference vertex.  "endingIndex"
    *     refers to an adjacent vertex.
    * Postcondition: A string of the direction is returned.
    */
    std::string Graph::determineDirection(int startingIndex, int endingIndex)
    const 
    {
       int startingRow = (startingIndex&lt;(width*width))?
          (startingIndex/width):((startingIndex-width*width)/width);
       int endingRow = (endingIndex&lt;(width*width))?
          (endingIndex/width):((endingIndex-width*width)/width);
       int startingColumn = startingIndex % width;
       int endingColumn = endingIndex % width;
          
       std::stringstream ss;   
       if(endingRow > startingRow)
          ss&lt;&lt;"S";
       else if(endingRow &lt; startingRow)
          ss&lt;&lt;"N";
       
       if(endingColumn > startingColumn)
          ss&lt;&lt;"E";
       else if(endingColumn &lt; startingColumn)
          ss&lt;&lt;"W";
                                   
       return ss.str();
    }
    
    /*======= class Node implementation =======*/ 
    
    /**
    * Purpose: This sets the distance value of a vertex.
    * Precondition: "distance" refers to distance value.
    * Postcondition: Member data "distance" is set.
    */
    void Node::setDistance(const int& distance) { this->distance = distance; }   
       
    /**
    * Purpose: This returns distance value of vertex.
    * Precondition: Vertex object is valid.
    * Postcondition: The vertex distance value is returned.
    */   
    int Node::getDistance() const { return distance; }
    
    /**
    * Purpose: This sets the member data "id".
    * Precondition: "id" is index corresponding to position in adjacency list.
    * Postcondition: Member data "id" is set.
    */
    void Node::setId(const int& id) { this->id = id; }
    
    /**
    * Purpose: This returns "id" value of vertex.
    * Precondition: Vertex object is valid.
    * Postcondition: The vertex id value is returned.
    */
    int Node::getId() const { return id; }  
    
    /**
    * Purpose: This sets the member data "parent".
    * Precondition: Vertex object is valid.
    * Postcondition: Member data "parent" points to its parent vertex.
    */       
    void Node::setParent(Node* parent) { this->parent = parent; }
    
    /**
    * Purpose: This returns address of this vertex's parent.
    * Precondition: Vertex object is valid.
    * Postcondition: The address of this vertex's parent is returned.
    */
    const Node* const Node::getParent() const { return parent; }    
    
    /**
    * Purpose: This compares two vertices based on distance values.
    * Precondition: "n1" and "n2" are pointers to vertices in the graph.
    * Postcondition: True is returned if "n1" is larger than or equal to "n2";
    *     otherwise, false is returned.
    */      
    bool Node::operator()(const Node* n1, const Node* n2) const {
       return !(n1->distance &lt; n2->distance);
    }       
    
    /**
    * Purpose: This returns set of vertices adjacent to "this" vertex object.
    * Precondition: Vertex object is valid.
    * Postcondition: A set of pointers to vertices adjacent to "this" vertex
    *     object is returned.
    */      
    const std::vector<Vertex*>& Node::getSetOfAdjacentVertices() const {
       return vertexPointers; 
    }
    
    /*======= class Edge implementation =======*/ 
    /**
    * Purpose: This creates a hash code for an edge object.
    * Precondition: "source" is the index of the source vertex.  "destination"
    *     is the index of the destination vertex.
    * Postcondition: The hashcode for "this" edge object is returned.
    */
    int Edge::hash(int source, int destination) {
       return (source*FACTOR) + (destination); 
    }    
    
    /**
    * Purpose: This compares two edge objects based on hashCode.
    * Precondition: "e1" and "e2" are two edge objects.
    * Postcondition: True is returned if both edge objects has the same hashCode;
    *     otherwise, false is returned.
    */      
    bool Edge::compare(const Edge& e1, const Edge& e2) { 
       return e1._hashCode==e2._hashCode;
    }
    
    /**
    * Purpose: This returns the index of source vertex of the directed arc.
    * Precondition: Edge object is valid.
    * Postcondition: The source vertex index of directed arc is returned.
    */      
    int Edge::getSource() const { return _source; }
    
    /**
    * Purpose: This returns the index of source vertex of the directed arc.
    * Precondition: "hashCode" is hash code of "this" edge object.
    * Postcondition: The source vertex index of directed arc is returned.
    */   
    int Edge::getSource(const int& hashCode) const { return hashCode/FACTOR; }
    
    /**
    * Purpose: This returns the index of destination vertex of directed arc.
    * Precondition: Edge object is valid.
    * Postcondition: The destination vertex index of directed arc is returned.
    */
    int Edge::getDestination() const { return _destination; }
    
    /**
    * Purpose: This returns the distance of the edge object.
    * Precondition: Edge object is valid.
    * Postcondition: The distance of edge object is returned.
    */
    int Edge::getDistance() const { return _distance; }
    
    /**
    * Purpose: This returns hash code of the edge object.
    * Precondition: Edge object is valid.
    * Postcondition: The hash code of edge object is returned.
    */
    int Edge::getHashCode() const { return _hashCode; }    
    
    /**
    * Purpose: This compares two edge objects based on hashcode.
    * Precondition: "e1" and "e2" are two edge objects.
    * Postcondition: True is returned if "e1" is larger than or equal to "e2";
    *     otherwise, false is returned.
    */      
    bool Edge::operator()(const Edge& e1, const Edge& e2) const {
       return !(e1._hashCode&lt;e2._hashCode);
    }  
    
    /*======= class MyBad implementation =======*/ 
    
    /**
    * Purpose: This returns the error message.
    * Precondition: MyBad object is valid.
    * Postcondition: The error message is returned.
    */
    const char* MyBad::what() const throw() { return msg.c_str(); }











    /******************************************************************************
    *  File: main.cpp
    *  Author:  Vaddanak Seng
    *  Purpose: We will test Dijkstra's algorithm on each instance of graphs
    *     in class BunchOfGraphs.
    ******************************************************************************/
    
    #include "bunchofgraphs.h"
    
    #include <iostream>
    
    /**
    * Purpose: This tests class BunchOfGraphs implementation.
    * Precondition: Class BunchOfGraphs and associated members were defined
    *     and implemented.
    * Postcondition: Operations on creating instances of graphs and running
    *     Dijkstra's algorithm were performed.  Results of finding path through
    *     each graph instance can be found in file "output.txt"
    *   
    *     NOTE:  The "input.txt" contains data for all instances of graph.
    *            The format of this file must be strictly adhered according to
    *            project description.  This program is designed to retrieve all
    *            the data from the "input.txt" file and create all instances of
    *            Graph based on the data.
    */
    int main(int argc, char ** args) {
       
       //BunchOfGraphs g("jim-input.txt");  
       BunchOfGraphs g("input.txt");
           
       return 0;
    }    


</code>
</pre>
</BODY>
</HTML>